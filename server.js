// server.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs-extra');
const cors = require('cors');
const ffmpeg = require('fluent-ffmpeg');

const app = express();
const PORT = 3000;

const UPLOAD_DIR = path.join(__dirname, 'public/uploads');
const THUMB_DIR = path.join(__dirname, 'public/thumbnails');

// Ensure upload folders exist
fs.ensureDirSync(UPLOAD_DIR);
fs.ensureDirSync(THUMB_DIR);

app.use(cors());
app.use(express.static('public'));
app.use(express.json());

// Define specific routes for HTML pages
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public/index.html'));
});

app.get('/login', (req, res) => {
    res.sendFile(path.join(__dirname, 'public/login.html'));
});

app.get('/users', (req, res) => {
    res.sendFile(path.join(__dirname, 'public/users.html'));
});

// Configure multer for disk storage
const storage = multer.diskStorage({
    destination: (req, file, cb) => cb(null, UPLOAD_DIR),
    filename: (req, file, cb) => {
        // Get device ID from request (if available)
        const deviceId = req.headers['device-id'] || req.query.deviceId || 'unknown';
        
        // Generate a unique name preserving the original filename
        // Format: deviceId_originalFilename
        const uniqueName = `${deviceId}_${file.originalname}`;
        cb(null, uniqueName);
    }
});
const upload = multer({ storage });

// Serve thumbnails statically
app.use('/thumbnails', express.static(THUMB_DIR));

// Upload route
app.post('/upload', upload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            console.error('❌ Upload error: No file received');
            return res.status(400).json({ success: false, message: 'No file received' });
        }

        console.log(`📤 Received file: ${req.file.originalname} (${req.file.size} bytes)`);
        
        // Get the uploaded file paths
        const originalname = req.file.originalname;
        const tempPath = req.file.path;
        const filename = req.file.filename; // This is the unique filename generated by multer
        const ext = path.extname(req.file.originalname).toLowerCase();
        const deviceId = req.headers['device-id'] || req.query.deviceId || 'unknown';
        
        // Get existing files
        const existingFiles = await fs.readdir(UPLOAD_DIR);
        
        console.log(`🔍 Checking for duplicates of '${originalname}', stored as '${filename}'`);

        // Debug: log all files and lengths
        existingFiles.forEach(f => console.log(`'${f}' (length: ${f.length})`));
        console.log(`filename to check: '${filename}' (length: ${filename.length})`);

        // Skip the just-uploaded file when checking for duplicates
        let isDuplicate = false;
        for (const existingFile of existingFiles) {
            if (existingFile === filename) continue; // skip the just-uploaded file
            if (existingFile === filename) {
                isDuplicate = true;
                break;
            }
        }
        if (isDuplicate) {
            console.log('Duplicate detected!');
            await fs.remove(tempPath);
            return res.status(400).json({ 
                success: false, 
                message: `This file already exists for this device. Please rename it or upload a different file.`,
                isDuplicate: true,
                duplicateFile: filename
            });
        } else {
            console.log('No duplicate, proceeding with upload.');
        }

        // === VIDEO THUMBNAIL GENERATION ===
        if (['.mp4', '.webm', '.mov'].includes(ext)) {
            const videoPath = tempPath;
            const thumbPath = path.join(THUMB_DIR, filename + '.jpg');
            ffmpeg(videoPath)
                .on('end', () => {
                    console.log('Thumbnail generated:', thumbPath);
                    res.json({ 
                        success: true, 
                        filename: filename,
                        originalname: req.file.originalname,
                        isDuplicate: false
                    });
                })
                .on('error', (err) => {
                    console.error('Error generating thumbnail:', err);
                    res.json({ 
                        success: true, 
                        filename: filename,
                        originalname: req.file.originalname,
                        isDuplicate: false,
                        thumbError: true
                    });
                })
                .screenshots({
                    count: 1,
                    timemarks: ['2'], // 2 seconds in
                    filename: filename + '.jpg',
                    folder: THUMB_DIR
                });
        } else {
            // Not a video, just respond
            res.json({ 
                success: true, 
                filename: filename,
                originalname: req.file.originalname,
                isDuplicate: false
            });
        }
    } catch (err) {
        console.error('❌ Upload error:', err);
        res.status(500).json({ 
            success: false, 
            error: err.toString(),
            message: 'File upload failed'
        });
    }
});


// Get file list
app.get('/uploads', async (req, res) => {
    try {
        const filter = req.query.filter || 'all';
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 32;
        const checkDuplicates = req.query.checkDuplicates === 'true';
        
        const files = await fs.readdir(UPLOAD_DIR);
        
        // Categorize files
        const fileObjects = await Promise.all(files.map(async filename => {
            const filePath = path.join(UPLOAD_DIR, filename);
            const stats = await fs.stat(filePath);
            const ext = path.extname(filename).toLowerCase();
            
            // Determine file type
            let type = 'other';
            if (['.jpg', '.jpeg', '.png', '.gif', '.webp'].includes(ext)) {
                type = 'image';
            } else if (['.mp4', '.webm', '.mov'].includes(ext)) {
                type = 'video';
            }
            
            return {
                filename,
                size: stats.size,
                modified: stats.mtime,
                type
            };
        }));
        
        // Filter files
        let filteredFiles = fileObjects;
        if (filter === 'image') {
            filteredFiles = fileObjects.filter(file => file.type === 'image');
        } else if (filter === 'video') {
            filteredFiles = fileObjects.filter(file => file.type === 'video');
        } else if (filter === 'other') {
            filteredFiles = fileObjects.filter(file => file.type === 'other');
        }
        
        // Sort files based on query parameters
        const sortField = req.query.sort || 'date';
        const sortOrder = req.query.order || 'desc';
        
        console.log(`Sorting by ${sortField} in ${sortOrder} order`);
        
        filteredFiles.sort((a, b) => {
            let valueA, valueB;
            
            // Determine which field to sort by
            if (sortField === 'date' || sortField === 'modified') {
                valueA = new Date(a.modified);
                valueB = new Date(b.modified);
            } else if (sortField === 'size') {
                valueA = a.size;
                valueB = b.size;
            } else if (sortField === 'name') {
                valueA = a.filename;
                valueB = b.filename;
            } else {
                // Default to date
                valueA = new Date(a.modified);
                valueB = new Date(b.modified);
            }
            
            // Apply sort order
            if (sortOrder === 'desc') {
                // For descending order, newer items first
                return valueB - valueA || valueB.localeCompare?.(valueA) || 0;
            } else {
                // For ascending order, older items first
                return valueA - valueB || valueA.localeCompare?.(valueB) || 0;
            }
        });
        
        // Count by type
        const counts = {
            images: fileObjects.filter(file => file.type === 'image').length,
            videos: fileObjects.filter(file => file.type === 'video').length,
            others: fileObjects.filter(file => file.type === 'other').length
        };
        counts.all = counts.images + counts.videos + counts.others;
        
        // For duplicate checking, return all files without pagination
        if (checkDuplicates) {
            return res.json({
                files: filteredFiles,
                counts,
                total: filteredFiles.length
            });
        }
        
        // Pagination
        const startIndex = (page - 1) * limit;
        const endIndex = page * limit;
        const paginatedFiles = filteredFiles.slice(startIndex, endIndex);
        
        // Calculate total pages
        const totalFiles = filteredFiles.length;
        const totalPages = Math.ceil(totalFiles / limit);
        
        // Always return a consistent response shape, even if the filtered list is empty
        res.json({
            files: paginatedFiles,
            counts,
            hasMore: endIndex < filteredFiles.length,
            page,
            totalFiles,
            totalPages
        });
    } catch (err) {
        console.error('Error listing files:', err);
        res.status(500).json({ 
            error: 'Failed to list files',
            message: err.message,
            files: [],
            counts: { images: 0, videos: 0, others: 0, all: 0 },
            hasMore: false,
            page: 1,
            totalFiles: 0,
            totalPages: 0
        });
    }
});

// Delete a file
app.delete('/delete/:filename', async (req, res) => {
    try {
        const filename = req.params.filename;
        const filePath = path.join(UPLOAD_DIR, filename);
        const thumbPath = path.join(THUMB_DIR, filename);
        
        // Remove the file
        await fs.remove(filePath);
        
        // Remove thumbnail if it exists
        try {
            await fs.remove(thumbPath);
        } catch (thumbErr) {
            console.warn(`Could not remove thumbnail for ${filename}:`, thumbErr);
            // Continue even if thumbnail deletion fails
        }
        
        // Get updated file counts
        const remainingFiles = await fs.readdir(UPLOAD_DIR);
        
        // Count files by type
        const counts = {
            images: 0,
            videos: 0,
            others: 0
        };
        
        for (const file of remainingFiles) {
            const ext = path.extname(file).toLowerCase();
            if (['.jpg', '.jpeg', '.png', '.gif', '.webp'].includes(ext)) {
                counts.images++;
            } else if (['.mp4', '.webm', '.mov'].includes(ext)) {
                counts.videos++;
            } else {
                counts.others++;
            }
        }
        
        counts.all = counts.images + counts.videos + counts.others;
        
        res.json({ 
            success: true, 
            message: `File ${filename} deleted successfully`,
            counts
        });
    } catch (err) {
        console.error('❌ Delete error:', err);
        res.status(500).json({ 
            success: false, 
            error: err.toString() 
        });
    }
});

// Rename a file
app.post('/rename', async (req, res) => {
    const { oldName, newName } = req.body;
    const oldPath = path.join(UPLOAD_DIR, oldName);
    const newPath = path.join(UPLOAD_DIR, newName);

    await fs.rename(oldPath, newPath);

    const oldThumb = path.join(THUMB_DIR, oldName);
    const newThumb = path.join(THUMB_DIR, newName);
    if (await fs.pathExists(oldThumb)) {
        await fs.rename(oldThumb, newThumb);
    }

    res.json({ success: true });
});

// Authentication endpoints - add after the other routes
// Simple in-memory user storage (replace with database in production)
let users = [
    { username: 'admin', password: 'admin123', isAdmin: true }
];

// For token storage
const tokens = new Map();

// Login endpoint
app.post('/api/login', (req, res) => {
    const { username, password } = req.body;
    
    // Check if user exists
    const user = users.find(u => 
        u.username === username && u.password === password);
    
    if (!user) {
        return res.status(401).json({ 
            success: false, 
            message: 'Invalid username or password' 
        });
    }
    
    // Generate a token
    const token = Math.random().toString(36).substring(2, 15) + 
                 Math.random().toString(36).substring(2, 15);
    
    // Store token (in production, use Redis or a proper session store)
    tokens.set(token, {
        username: user.username,
        isAdmin: user.isAdmin,
        created: Date.now()
    });
    
    res.json({
        success: true,
        token,
        username: user.username,
        isAdmin: user.isAdmin
    });
});

// Logout endpoint
app.post('/api/logout', (req, res) => {
    const { token } = req.body;
    
    if (token && tokens.has(token)) {
        tokens.delete(token);
    }
    
    res.json({ success: true });
});

// Get users endpoint (admin only)
app.get('/api/users', (req, res) => {
    const token = req.headers.authorization;
    
    // Check token
    if (!token || !tokens.has(token) || !tokens.get(token).isAdmin) {
        return res.status(401).json({ 
            success: false, 
            message: 'Unauthorized' 
        });
    }
    
    // Return users without passwords
    const safeUsers = users.map(({ username, isAdmin }) => ({ 
        username, 
        isAdmin 
    }));
    
    res.json({ success: true, users: safeUsers });
});

// Create user endpoint (admin only)
app.post('/api/users', (req, res) => {
    const token = req.headers.authorization;
    const { username, password, isAdmin } = req.body;
    
    // Check token
    if (!token || !tokens.has(token) || !tokens.get(token).isAdmin) {
        return res.status(401).json({ 
            success: false, 
            message: 'Unauthorized' 
        });
    }
    
    // Check if username already exists
    if (users.some(u => u.username === username)) {
        return res.status(400).json({ 
            success: false, 
            message: 'Username already exists' 
        });
    }
    
    // Add new user
    users.push({ username, password, isAdmin: !!isAdmin });
    
    res.json({ success: true });
});

// Update user endpoint (admin only)
app.put('/api/users/:username', (req, res) => {
    const token = req.headers.authorization;
    const { username } = req.params;
    const { password, isAdmin } = req.body;
    
    // Check token
    if (!token || !tokens.has(token) || !tokens.get(token).isAdmin) {
        return res.status(401).json({ 
            success: false, 
            message: 'Unauthorized' 
        });
    }
    
    // Find user
    const userIndex = users.findIndex(u => u.username === username);
    if (userIndex === -1) {
        return res.status(404).json({ 
            success: false, 
            message: 'User not found' 
        });
    }
    
    // Update user
    if (password) {
        users[userIndex].password = password;
    }
    
    if (typeof isAdmin === 'boolean') {
        users[userIndex].isAdmin = isAdmin;
    }
    
    res.json({ success: true });
});

// Delete user endpoint (admin only)
app.delete('/api/users/:username', (req, res) => {
    const token = req.headers.authorization;
    const { username } = req.params;
    
    // Check token
    if (!token || !tokens.has(token) || !tokens.get(token).isAdmin) {
        return res.status(401).json({ 
            success: false, 
            message: 'Unauthorized' 
        });
    }
    
    // Prevent deleting the current user
    if (tokens.get(token).username === username) {
        return res.status(400).json({ 
            success: false, 
            message: 'Cannot delete your own account' 
        });
    }
    
    // Find and remove user
    const userIndex = users.findIndex(u => u.username === username);
    if (userIndex === -1) {
        return res.status(404).json({ 
            success: false, 
            message: 'User not found' 
        });
    }
    
    users.splice(userIndex, 1);
    
    res.json({ success: true });
});

// On-demand video thumbnail generation endpoint
app.post('/api/generate-thumbnail', async (req, res) => {
    const { filename } = req.body;
    if (!filename) return res.status(400).json({ success: false, message: 'No filename provided' });

    const videoPath = path.join(UPLOAD_DIR, filename);
    const thumbPath = path.join(THUMB_DIR, filename + '.jpg');

    // Check if video exists
    if (!await fs.pathExists(videoPath)) {
        return res.status(404).json({ success: false, message: 'Video not found' });
    }

    // If thumbnail already exists, return success
    if (await fs.pathExists(thumbPath)) {
        return res.json({ success: true, thumbnail: `/thumbnails/${filename}.jpg` });
    }

    // Generate thumbnail
    ffmpeg(videoPath)
        .on('end', () => {
            res.json({ success: true, thumbnail: `/thumbnails/${filename}.jpg` });
        })
        .on('error', (err) => {
            res.status(500).json({ success: false, message: 'Failed to generate thumbnail', error: err.toString() });
        })
        .screenshots({
            count: 1,
            timemarks: ['1'],
            filename: filename + '.jpg',
            folder: THUMB_DIR
        });
});

// Start server
app.listen(PORT, () => {
    const os = require('os');
    const networkInterfaces = os.networkInterfaces();
    const localIP = Object.values(networkInterfaces)
        .flat()
        .find(interface => !interface.internal && interface.family === 'IPv4')?.address;
    console.log(`🚀 Server running at http://localhost:${PORT}`);
    console.log(`🌐 Local network: http://${localIP}:${PORT}`);
});
